# Copyright 2024 D-Wave Systems Inc.
#
#    Licensed under the Apache License, Version 2.0 (the "License");
#    you may not use this file except in compliance with the License.
#    You may obtain a copy of the License at
#
#        http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS,
#    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#    See the License for the specific language governing permissions and
#    limitations under the License.

import collections.abc
import typing

import numpy
import numpy.typing

from dwave.optimization.model import Model
from dwave.optimization.symbols import (
    Absolute,
    Add,
    AdvancedIndexing,
    All,
    Any,
    BasicIndexing,
    Constant,
    Equal,
    LessEqual,
    Max,
    Min,
    Modulus,
    Multiply,
    NaryAdd,
    NaryMultiply,
    Negative,
    PartialSum,
    Permutation,
    Prod,
    Reshape,
    Size,
    Subtract,
    Sum,
)

_ShapeLike: typing.TypeAlias = typing.Union[int, collections.abc.Sequence[int]]

_GraphManagerT = typing.TypeVar('_GraphManagerT', bound='_GraphManager')


class _GraphManager:
    def __init__(self): ...

    @property
    def _states(self) -> "States": ...
    def _constant(self, array_like: numpy.typing.ArrayLike) -> Constant: ...

    @classmethod
    def _from_file(
        cls: typing.Type[_GraphManagerT],
        file: typing.Union[typing.BinaryIO, collections.abc.ByteString, str],
        *,
        check_header: bool = True,
    ) -> _GraphManagerT: ...

    def _into_file(
        self,
        file: typing.Union[typing.BinaryIO, collections.abc.ByteString, str],
        *,
        max_num_states: int = 0,
        only_decision: bool = False,
    ): ...
    def _is_locked(self) -> bool: ...
    def _iter_symbols(self) -> collections.abc.Iterator["Symbol"]: ...
    def _num_nodes(self) -> int: ...
    def _num_symbols(self) -> int: ...
    def _remove_unused_symbols(self) -> int: ...
    def _state_size(self) -> int: ...

    def _to_file(
        self,
        *,
        max_num_states: int = 0,
        only_decision: bool = False,
    ) -> typing.BinaryIO: ...

    # networkx might not be installed, so we just say we return an object.
    def _to_networkx(self) -> object: ...
    def _unlock(self): ...

    @property
    def _objective(self) -> "ArraySymbol": ...
    def _add_constraint(self, value: "ArraySymbol") -> "ArraySymbol": ...
    def _iter_constraints(self) -> collections.abc.Iterator["ArraySymbol"]: ...
    def _iter_decisions(self) -> collections.abc.Iterator["Symbol"]: ...
    def _minimize(self, value: "ArraySymbol"): ...
    def _num_constraints(self) -> int: ...
    def _num_decisions(self) -> int: ...


class States:
    def __init__(self, model: Model): ...
    def __len__(self) -> int: ...
    def clear(self): ...

    def from_file(
        self,
        file: typing.Union[typing.BinaryIO, collections.abc.ByteString, str],
        *,
        replace: bool = True,
        check_header: bool = True,
    ) -> Model: ...
    def from_future(self, future: object, result_hook: collections.abc.Callable): ...
    def initialize(self): ...

    def into_file(
        self,
        file: typing.Union[typing.BinaryIO, collections.abc.ByteString, str],
    ): ...

    def resize(self, n: int): ...
    def resolve(self): ...
    def size(self) -> int: ...
    def to_file(self) -> typing.BinaryIO: ...


class Symbol:
    def __init__(self, *args, **kwargs) -> typing.NoReturn: ...
    def equals(self, other: "Symbol") -> bool: ...
    def expired(self) -> bool: ...
    def has_state(self, index: int = 0) -> bool: ...
    def id(self) -> int: ...
    def iter_predecessors(self) -> collections.abc.Iterator["Symbol"]: ...
    def iter_successors(self) -> collections.abc.Iterator["Symbol"]: ...
    def maybe_equals(self, other: "Symbol") -> int: ...
    def reset_state(self, index: int): ...
    def shares_memory(self, other: "Symbol") -> bool: ...
    def state_size(self) -> int: ...
    def topological_index(self) -> int: ...


class ArraySymbol(Symbol):
    def __init__(self, *args, **kwargs) -> typing.NoReturn: ...
    def __abs__(self) -> Absolute: ...
    def __add__(self, rhs: "ArraySymbol") -> Add: ...
    def __bool__(self) -> typing.NoReturn: ...
    def __eq__(self, rhs: "ArraySymbol") -> Equal: ...  # type: ignore

    def __getitem__(
        self,
        index: typing.Union[Symbol, int, slice, tuple],
    ) -> typing.Union[AdvancedIndexing, BasicIndexing, Permutation]: ...

    def __iadd__(self, rhs: "ArraySymbol") -> NaryAdd: ...
    def __imul__(self, rhs: "ArraySymbol") -> NaryMultiply: ...
    def __le__(self, rhs: "ArraySymbol") -> LessEqual: ...
    def __mod__(self, rhs: "ArraySymbol") -> Modulus: ...
    def __mul__(self, rhs: "ArraySymbol") -> Multiply: ...
    def __neg__(self) -> Negative: ...
    def __pow__(self, exponent: int) -> "ArraySymbol": ...
    def __sub__(self, rhs: "ArraySymbol") -> Subtract: ...
    def all(self) -> All: ...
    def any(self) -> Any: ...
    def max(self) -> Max: ...
    def min(self) -> Min: ...
    def ndim(self) -> int: ...
    def prod(self) -> Prod: ...
    def reshape(self, shape: _ShapeLike) -> Reshape: ...
    def shape(self) -> tuple[int, ...]: ...
    def size(self) -> typing.Union[int, Size]: ...
    def sqrt(self) -> "ArraySymbol": ...
    def state(self, index: int = 0, *, copy: bool = True) -> numpy.ndarray: ...
    def state_size(self) -> int: ...
    def strides(self) -> tuple[int, ...]: ...

    def sum(
        self, axis: typing.Optional[int] = None
    ) -> typing.Union[Sum, PartialSum]: ...

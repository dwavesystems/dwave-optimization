# Copyright 2024 D-Wave Systems Inc.
#
#    Licensed under the Apache License, Version 2.0 (the "License");
#    you may not use this file except in compliance with the License.
#    You may obtain a copy of the License at
#
#        http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS,
#    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#    See the License for the specific language governing permissions and
#    limitations under the License.

import collections.abc
import os
import typing

import numpy

import dwave.optimization.symbols as symbols

_ShapeLike: typing.TypeAlias = typing.Union[int, collections.abc.Sequence[int]]
_SymbolLike: typing.TypeAlias = typing.Union[numpy.typing.ArrayLike, ArraySymbol]

_GraphSubclass = typing.TypeVar("_GraphSubclass", bound="_Graph")

DEFAULT_SERIALIZATION_VERSION: tuple[int, int]
KNOWN_SERIALIZATION_VERSIONS: tuple[tuple[int, int], ...]

class _Graph:
    def __init__(self, *args, **kwargs) -> typing.NoReturn: ...

    def add_constraint(self, value: ArraySymbol) -> ArraySymbol: ...
    def decision_state_size(self) -> int: ...

    @classmethod
    def from_file(
        cls: typing.Type[_GraphSubclass],
        file: typing.Union[bytes, os.PathLike, str, typing.BinaryIO],
        *,
        substitute: typing.Optional[collections.abc.Mapping[str, collections.abc.Callable]] = None,
        ) -> _GraphSubclass: ...

    def into_file(
        self,
        file: typing.Union[bytes, os.PathLike, str, typing.BinaryIO],
        *,
        max_num_states: int = 0,
        only_decision: bool = False,
        version: typing.Optional[tuple[int, int]] = None
        ): ...

    def is_locked(self) -> bool: ...
    def iter_constraints(self) -> collections.abc.Iterator[ArraySymbol]: ...
    def iter_decisions(self) -> collections.abc.Iterator[Symbol]: ...
    def iter_inputs(self) -> collections.abc.Iterator[symbols.Input]: ...
    def iter_symbols(self) -> collections.abc.Iterator[Symbol]: ...
    def lock(self): ...
    def minimize(self, value: ArraySymbol): ...
    def num_constraints(self) -> int: ...
    def num_decisions(self) -> int: ...
    def num_inputs(self) -> int: ...
    def num_nodes(self) -> int: ...
    def num_symbols(self) -> int: ...
    def remove_unused_symbols(self) -> int: ...
    def state_size(self) -> int: ...
    def unlock(self): ...

class Symbol:
    def __init__(self, *args, **kwargs) -> typing.NoReturn: ...
    def equals(self, other: Symbol) -> bool: ...
    def expired(self) -> bool: ...
    def has_state(self, index: int = 0) -> bool: ...
    def id(self) -> int: ...
    def iter_predecessors(self) -> collections.abc.Iterator[Symbol]: ...
    def iter_successors(self) -> collections.abc.Iterator[Symbol]: ...
    def maybe_equals(self, other: Symbol) -> int: ...
    def reset_state(self, index: int): ...
    def shares_memory(self, other: Symbol) -> bool: ...
    def state_size(self) -> int: ...
    def topological_index(self) -> int: ...

class ArraySymbol(Symbol):
    def __init__(self, *args, **kwargs) -> typing.NoReturn: ...
    def __abs__(self) -> symbols.Absolute: ...
    def __add__(self, rhs: _SymbolLike) -> symbols.Add: ...
    def __bool__(self) -> typing.NoReturn: ...
    def __eq__(self, rhs: _SymbolLike) -> symbols.Equal: ...
    def __ge__(self, rhs: _SymbolLike) -> symbols.LessEqual: ...

    def __getitem__(
        self,
        index: typing.Union[Symbol, int, slice, tuple],
    ) -> typing.Union[symbols.AdvancedIndexing, symbols.BasicIndexing, symbols.Permutation]: ...

    def __iadd__(self, rhs: _SymbolLike) -> symbols.NaryAdd: ...
    def __imul__(self, rhs: _SymbolLike) -> symbols.NaryMultiply: ...
    def __iter__(self) -> typing.Iterator[ArraySymbol]: ...
    def __le__(self, rhs: _SymbolLike) -> symbols.LessEqual: ...
    def __mod__(self, rhs: _SymbolLike) -> symbols.Modulus: ...
    def __mul__(self, rhs: _SymbolLike) -> symbols.Multiply: ...
    def __neg__(self) -> symbols.Negative: ...
    def __pow__(self, exponent: int) -> ArraySymbol: ...
    def __radd__(self, lhs: _SymbolLike) -> symbols.Add: ...
    def __rmod__(self, lhs: _SymbolLike) -> symbols.Modulus: ...
    def __rmul__(self, lhs: _SymbolLike) -> symbols.Multiply: ...
    def __rsub__(self, lhs: _SymbolLike) -> symbols.Subtract: ...
    def __rtruediv__(self, lhs: _SymbolLike) -> symbols.Divide: ...
    def __sub__(self, rhs: _SymbolLike) -> symbols.Subtract: ...
    def __truediv__(self, rhs: _SymbolLike) -> symbols.Divide: ...
    def all(self) -> symbols.All: ...
    def any(self) -> symbols.Any: ...
    def copy(self) -> symbols.Copy: ...
    def flatten(self) -> symbols.Reshape: ...
    def max(self, *, initial: typing.Optional[float] = None) -> symbols.Max: ...
    def min(self, *, initial: typing.Optional[float] = None) -> symbols.Min: ...
    def ndim(self) -> int: ...
    def prod(
        self,
        *,
        axis: typing.Optional[int] = None,
        initial: typing.Optional[float] = None,
    ) -> typing.Union[symbols.Prod, symbols.PartialProd]: ...
    def reshape(self, *shape: _ShapeLike) -> ArraySymbol: ...
    def resize(
        self,
        shape: _ShapeLike,
        fill_value: typing.Optional[float] = None,
    ) -> symbols.Resize: ...
    def shape(self) -> tuple[int, ...]: ...
    def size(self) -> typing.Union[int, symbols.Size]: ...
    def sqrt(self) -> ArraySymbol: ...
    def state(self, index: int = 0, *, copy: bool = True) -> numpy.ndarray: ...
    def state_size(self) -> int: ...
    def strides(self) -> tuple[int, ...]: ...
    def sum(
        self,
        *,
        axis: typing.Optional[int] = None,
        initial: typing.Optional[float] = None,
    ) -> typing.Union[symbols.Sum, symbols.PartialSum]: ...
